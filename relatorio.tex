\documentclass[a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}

\title{MAC0438 - Programação Concorrente - 1s2012 \\ Relatório}
\author{Thiago de Gouveia Nunes \\ Wilson Kazuo Mizutani}

\begin{document}

\maketitle
\tableofcontents

\clearpage
\section{Introdução}
  Esse relatório trata das decisões tomadas na implementação desse EP. Também
fornece uma saída do programa para a entrada de exemplo fornecida no enunciado,
além de explicitar a localização no código da implementação da barreira
simétrica usada.
  Informações sobre como como compilar, as dependÊncias necessárias e o modo de
uso do programa encontram-se no arquivo LEIAME.

\section{Solução desenvolvida}

  \subsection{Ideia geral}
    A ideia geral da nossa solução se divide em duas partes:
      \begin{itemize}
        \item[\textbf 1.]
          Estender o algoritmo de busca em largura (Breadth-First Search, um
          caso particular do algoritmo de Dijkstra no qual todas as arestas
          possuem custo 1) para que ele encontre não só o menor caminhos, mas
          sim os {\textbf n} menores caminhos.
        \item[\textbf 2.]
          Refatorar esse algoritmo para usar programação concorrente, de tal
          maneira que cada thread seja responsável por tentar encontrar um novo
          caminho e depois sincronizar com as demais, criando assim um processo
          iterativo.
      \end{itemize}

  \subsection{Estendendo a busca em largura}
    Basicamente, aproveitamos a propriedade da busca em largura na qual um novo
    vértice retirado da fila está sendo visitado pela primeira vez através do
    menor caminho.

    Estendemos o algoritmo para ter uma fila de caminhos ao invés de vértices,
    por conveniência, e ao invés de deixarmos de visitar um vértice após passar
    por ele apenas uma vez, o fazemos após \textbf{n} vezes (o que significa
    que ele já tem n caminhos mínimos terminando nele).

    Assim, a propriedade do nosso algoritmo (ainda no caso não-concorrente)
    seria que um novo caminho retirado da fila é o próximo menor caminho que
    termina no mesmo último vértice que ele. Mas como o enunciado do EP pedia
    que cada thread cuidasse de apenas um caminho, mudamos isso de forma que, na
    verdade, insere-se apenas candidatos a caminho na fila. A propriedade fica
    portanto que um novo candidato retirado da fila \textit{pode} ser o próximo
    menor caminho que termina no seu último vértice, \textit{contanto que ele
    não seja um ciclo}.

    Uma consequência disso é que o programa vai com certeza ficar menos
    eficiente, pois há menos restrições sobre quem entra na fila, e portanto ela
    potencialmente terá mais elementos do que na maneira anterior.

  \subsection{Aplicando concorrência}
    Pensamos em várias maneiras de fazer isso. O grande problema é que a ordem
    com que os caminhos são encontrados é indeterminada, então não podemos
    assumir que os n primeiros encontrados sejam, de fato, os n menores. Vimos
    duas maneiras de lidar com isso.

    Uma seria controlar a inserção em uma fila compartilhada através de um
    buffer intermediário que garantisse sua ordem. Isso apresenta dois
    problemas: a necessidade de uma fila compartilhada, e o fato de que a
    inserção nela não seria verdadeiramente paralelizada, pois seria justamente
    preciso serializar as threads para que elas inserissem na ordem correta.

    A outra maneira e deixar o trabalho todo para a lista de caminhos de cada
    vértice. Elas mesmas cuidariam de guardar o n menores caminhos, descartando
    os demais. Assim, cada thread poderia ter sua própria fila, e no total o
    algoritmo seria bem mais paralelizável. O problema seria que ua inserção de
    um dos n verdadeiramente menores caminho custaria com a melhor implementação
    que pudemos pensar O(log(n)) ao invés de apenas O(1).

    No final, optamos pela segunda opção, apostando que uma maior paralelização
    do algoritmo compensasse a inserção de novos caminhos mínimos.

\section{Implementação da solução}

  \subsection{Breve descrição das classes}

  \subsection{Alguns detalhes de implementação}

  \subsection{Sobre a barreira simétrica usada}

\section{Resultados}

  \subsection{Resultado para o grafo da NSFNet}

  \subsection{Comparações de eficiência}

\section{Conclusões}

\end{document}
